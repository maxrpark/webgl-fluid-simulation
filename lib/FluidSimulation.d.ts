import Time from "./utils/Time.js";
import Material from "./shaders/Material.js";
import Program from "./Program.js";
import WebGLContext from "./WebGLContext.js";
import Canvas from "./Canvas.js";
import Pointer from "./Pointer.js";
import { FramebufferObject } from "./FramebufferObject.js";
interface configInt {
    isTexture: boolean;
    simResolution: number;
    dyeResolution: number;
    densityDissipation: number;
    velocityDissipation: number;
    pressure: number;
    pressureIterations: number;
    curl: number;
    splatRadius: number;
    splatForce: number;
    shading: boolean;
    colorful: boolean;
    colorUpdateSpeed: number;
    paused: boolean;
    backGroundColor: string;
    transparent: boolean;
    bloom: boolean;
    bloomIterations: number;
    bloomResolution: number;
    bloomIntensity: number;
    bloomThreshold: number;
    bloomSoftKnee: number;
    sunrays: boolean;
    sunraysResolution: number;
    sunraysWeigth: number;
    onlyHover: boolean;
    canvasContainer: string;
    className: string;
    fluidColor?: string;
}
interface Props {
    canvas?: HTMLCanvasElement;
    config?: {
        isTexture?: boolean;
        simResolution?: number;
        dyeResolution?: number;
        densityDissipation?: number;
        velocityDissipation?: number;
        pressure?: number;
        pressureIterations?: number;
        curl?: number;
        splatRadius?: number;
        splatForce?: number;
        shading?: boolean;
        colorful?: boolean;
        colorUpdateSpeed?: number;
        paused?: boolean;
        backGroundColor?: string;
        transparent?: boolean;
        bloom?: boolean;
        bloomIterations?: number;
        bloomResolution?: number;
        bloomIntensity?: number;
        bloomThreshold?: number;
        bloomSoftKnee?: number;
        sunrays?: boolean;
        sunraysResolution?: number;
        sunraysWeigth?: number;
        onlyHover?: boolean;
        className?: string;
        canvasContainer?: any;
        fluidColor?: string;
    };
}
export interface FluidSimulationInt {
    canvas?: HTMLCanvasElement | undefined;
}
export default class FluidSimulation {
    canvas?: HTMLCanvasElement;
    uuid: string;
    canvasClass: Canvas;
    webGLContext: WebGLContext;
    gl: WebGL2RenderingContext;
    displayMaterial: Material;
    time: Time;
    texture: any;
    colorUpdateTimer: number;
    pointers: Pointer[];
    splatStack: any[];
    blurProgram: Program;
    copyProgram: Program;
    clearProgram: Program;
    colorProgram: Program;
    bloomPrefilterProgram: Program;
    bloomBlurProgram: Program;
    bloomFinalProgram: Program;
    sunraysMaskProgram: Program;
    sunraysProgram: Program;
    splatProgram: Program;
    advectionProgram: Program;
    divergenceProgram: Program;
    curlProgram: Program;
    vorticityProgram: Program;
    pressureProgram: Program;
    gradienSubtractProgram: Program;
    config: configInt;
    constructor(props: Props);
    multipleSplats(amount: number): void;
    drawColor(target: any, color: any): void;
    updateColors(dt: number): void;
    applyInputs(): void;
    splatPointer(pointer: Pointer): void;
    splat(x: number, y: number, dx: number, dy: number, color: {
        r: any;
        g: any;
        b: any;
        a?: number;
    }): void;
    correctRadius(radius: number): number;
    applyBloom(source: any, destination: any): void;
    applySunrays(source: any, mask: any, destination: any): void;
    blur(target: any, temp: any, iterations: number): void;
    step(dt: number): void;
    drawDisplay(target: any): void;
    getTextureScale(texture: {
        texture?: WebGLTexture | null;
        width: any;
        height: any;
        attach?: (id: number) => number;
    }, width: number, height: number): {
        x: number;
        y: number;
    };
    render(target: any): void;
    update(): void;
    onResizeFBO(target: FramebufferObject): void;
    onResize(): void;
    mouseMove(e: MouseEvent): void;
    mouseUp(): void;
    mouseDown(e: MouseEvent): void;
    touchStart(e: any): void;
    touchMove(e: any): void;
    touchEnd(e: any): void;
    keyDown(e: any): void;
}
export {};
